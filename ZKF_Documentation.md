# Project LEO: Distributed Zero-Knowledge Fragmentation (ZKF) Layer Documentation

## 1. Introduction

The Distributed Zero-Knowledge Fragmentation (ZKF) Layer is a core component of Project LEO's decentralized cognitive architecture, designed to address the limitations of traditional Zero-Knowledge Proof (ZKP) systems in real-time decentralized intelligence applications. Instead of requiring a single prover to generate complete cryptographic proofs for entire computations, ZKF decomposes correctness verification into micro-attestations that are distributed across the mesh network, verified independently at each node, and reconstructed into global correctness guarantees through Byzantine-resilient ADMM consensus [1]. This approach transforms the classical ZKP prover from a single computational entity into a distributed verification fabric, enabling sub-millisecond verification times.

## 2. Core Concepts

### 2.1 Motivation and Paradigm

Traditional ZKP systems suffer from monolithic bottlenecks due to the time-consuming nature of generating complete proofs. LEO's ZKF paradigm overcomes this by fragmenting the proof generation process. Each node is responsible for proving only that it correctly applied its local transformation to its local state, without revealing the state itself. This significantly reduces the complexity and latency of proof generation, making real-time decentralized reasoning feasible.

### 2.2 Fragment Components

Each ZKF fragment (micro-attestation) consists of four key components:

*   **Local Constraint Satisfaction (LCS)**: A binary indicator (1 or 0) confirming that the local transformation applied by the node resulted in a state within acceptable correctness tolerances. Mathematically, this checks if the norm of the difference between the function applied to the local state and the transformed local state is within a defined delta `δc`.
*   **Local Commitment (Com)**: A cryptographic hash of the transformed state. This provides collision resistance and unlinkability, while still allowing for global consistency checks without exposing the raw state.
*   **Small-LM Consistency Signature (SLMCS)**: A semantic checksum, typically a value between 0 and 1, generated by a 
Small-LM (Small Language Model) that verifies the local update's consistency with the node's knowledge slice, expected reasoning direction, and current memory state.
*   **Entropy-Bounded Noise Vector**: A controlled noise vector added to preserve zero-knowledge properties, maintain ADMM convergence stability, and prevent local state reconstruction. The norm of this noise vector is bounded by `δn`.

## 3. `ZKFLayer` Class Implementation

The `ZKFLayer` class in `leo_core/brain/zkf_layer.py` provides the functionality for generating and verifying these fragments.

### 3.1 Initialization

```python
class ZKFLayer:
    def __init__(self, node_id: str, tolerance: float = 1e-5, semantic_threshold: float = 0.8):
        self.node_id = node_id
        self.delta_c = tolerance  # Correctness tolerance
        self.tau = semantic_threshold  # Semantic checksum threshold
        self.delta_n = 0.01  # Entropy-bounded noise limit
```

- `node_id`: A unique identifier for the LEO node.
- `tolerance` (`delta_c`): The threshold for local constraint satisfaction.
- `semantic_threshold` (`tau`): The minimum acceptable semantic score for a fragment to be considered valid.
- `delta_n`: The maximum bound for the noise vector.

### 3.2 `generate_fragment` Method

```python
def generate_fragment(self, 
                      local_state: np.ndarray, 
                      transformed_state: np.ndarray, 
                      semantic_score: float) -> Dict[str, Any]:
    # ... implementation ...
```

This method creates a ZKF fragment. It takes the `local_state` before transformation, the `transformed_state` after the local computation, and a `semantic_score` (simulated from a Small-LM) as input. It calculates the LCS, generates a cryptographic commitment (Com), incorporates the SLMCS, and adds an entropy-bounded noise vector.

### 3.3 `verify_fragment` Method

```python
def verify_fragment(self, fragment: Dict[str, Any], state_to_verify: Optional[np.ndarray] = None) -> bool:
    # ... implementation ...
```

This method verifies a given ZKF fragment against the defined acceptance criteria. It checks the LCS, SLMCS, and the noise bound. Optionally, if `state_to_verify` is provided, it also verifies the cryptographic commitment (Com) against the hash of the provided state.

### 3.4 `aggregate_attestations` Method

```python
def aggregate_attestations(self, fragments: list) -> float:
    # ... implementation ...
```

This method takes a list of ZKF fragments from various nodes and calculates a global attestation score. This score represents the network's confidence in the collective correctness of the distributed computations, based on the validity of individual fragments.

## 4. Integration with `HybridBrain`

The `ZKFLayer` is integrated into the `HybridBrain`'s cognitive circuit as a new operational step (`ZKF`). After the ADMM consensus step, the `_op_zkf_verification` method is called to generate and verify a ZKF fragment for the consensus output. This ensures that the decentralized consensus is not only achieved but also cryptographically attested for its correctness and semantic consistency.

## 5. Usage Example

```python
import numpy as np
from leo_core.brain.zkf_layer import ZKFLayer
from leo_core.brain.admm_engine import ADMMEngine

# Initialize components
zkf = ZKFLayer(node_id="Example-Node")
admm = ADMMEngine(dimension=64)

# Simulate a local computation (e.g., ADMM local step)
local_state_before = np.random.rand(64)
local_state_after = admm.local_step(local_state_before) # Assuming admm.local_step takes a state

# Simulate semantic score from a Small-LM
semantic_score = 0.98

# Generate ZKF Fragment
fragment = zkf.generate_fragment(
    local_state=local_state_before,
    transformed_state=local_state_after,
    semantic_score=semantic_score
)

# Verify Fragment
is_valid = zkf.verify_fragment(fragment, state_to_verify=local_state_after)

print(f"ZKF Fragment Valid: {is_valid}")
```

## References

[1] LEO Whitepaper: Decentralized Cognitive Architecture. (Internal Document) [./LEO_Whitepaper.docx](file://LEO_Whitepaper.docx)
